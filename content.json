{"meta":{"title":"CalvinLee","subtitle":null,"description":null,"author":"Calvin Lee","url":"http://coderdog.duapp.com"},"pages":[],"posts":[{"title":"超轻量模板引擎","slug":"超轻量模板引擎","date":"2018-03-27T14:59:16.000Z","updated":"2018-03-27T15:36:11.000Z","comments":true,"path":"2018/03/27/超轻量模板引擎/","link":"","permalink":"http://coderdog.duapp.com/2018/03/27/超轻量模板引擎/","excerpt":"","text":"还在痛苦的手工拼接HTML？ 使用模板引擎渲染出目标HTMl，避免手工拼接的错误，同时增加模板代码的可读性。 话不多说，先看代码，此demo实现了一个轻量的模板引擎。 模板引擎的核心正则表达式的单元匹配，以及replace函数。 模板采用双大括号的形式来标识此处是模板插槽，匹配到的可以是一个变量，同时也可以是对象访问属性。 replace函数第二个参数，支持传入function配合正则的匹配。 1/&#123;&#123;((\\w+\\.?)+)&#125;&#125;/g 正则表达式当中一个括号代表一个匹配组 \\w 匹配字母、数字、下划线。等价于[A-Za-z0-9_] + 匹配前面的子表达式一次或多次 ？ 匹配前面的子表达式零次或一次 render 函数的实现支持对象的属性访问 123456789101112function render(tpl, data) &#123; var reg = /&#123;&#123;((\\w+\\.?)+)&#125;&#125;/g return tpl.replace(reg, function(matchItem, keyName) &#123; let keys = keyName.split('.'); if (keys.length === 1) return data[keys[0]]; let res = data; for (let item of keys) &#123; res = res[item]; &#125; return res; &#125;)&#125;","categories":[],"tags":[]},{"title":"SSR原理","slug":"SSR原理","date":"2017-09-07T14:58:08.000Z","updated":"2017-09-07T16:46:40.000Z","comments":true,"path":"2017/09/07/SSR原理/","link":"","permalink":"http://coderdog.duapp.com/2017/09/07/SSR原理/","excerpt":"","text":"在品味了各种前端框架所带来开发的效率提升时，我们又回到了传统HTML工作机制的讨论。 前端框架在开发SPA应用时，浏览器一开始只是加载了一个框架，在执行了app.js后才开始根据数据来构建DOM。 那么这时会出现一些新的问题 搜索引擎爬虫爬到的只是一个框架，它不会来渲染你的数据。（不能SEO） 浏览器加载的是一个框架，数据需要再次请求网络，首屏加载时间过长。（用户体验度低） 为了解决上面遇到的问题，勤劳的工程师想出了一个解决方案，下满我来和大家分享下。 Virtual DOMVirtual DOM是React性能卓越的大杀器，那时其他框架还不具备VD人们也经常争论性能到底哪家强。 框架将数据渲染为虚拟DOM，这时通过diff算法与真实DOM对比找出不同的之处，然后通过render函数维护DOM。 说了这么多就是内存里存了个DOM结构。 DOM本身是一种树型结构（Tree），虚拟DOM采用红黑树实现 状态机（Vuex、Redux）前端数据持久化以及标准数据流，这个标准数据流在服务端渲染时起到了数据预加载的作用。服务端渲染时会在组件实例上增加一个生命周期函数，这时只需要把对应的action写在函数里服务端就会加载数据。 由于采用标准数据流，数据从getter里面取，服务端会自动把这些数据设置到render context中。 数据拿到了可以渲染Virtual DOM了。 SSRSSR(Server Side Render)服务器端渲染，Virtual DOM在不执行diff时render函数直接渲染，此时生成的DOM就是传统的HTML。此时HTTP服务器将这个渲染好的HTML文本流返回浏览器，这时我们就又回到了传统的HTML。 总结之所以最后才介绍主角（SSR），是因为这个解决方案的核心离不开Virtual DOM与状态机的标准数据流，目前主流前端框架均支持了SSR特性。 如果没有Virtual DOM与状态机，那么这件事儿能解决不？答案是肯定的，想想e2e test。 下期预告SSR听着很过瘾，但是想自己搭建一套过过瘾却不知如何下手，下期就带大家一起搭建一套。 怕麻烦，开箱即用的方案 Nuxt","categories":[],"tags":[]},{"title":"MVVM的基础原理与实现","slug":"MVVM的基础原理与实现","date":"2017-08-08T01:08:14.000Z","updated":"2017-08-08T16:03:29.000Z","comments":true,"path":"2017/08/08/MVVM的基础原理与实现/","link":"","permalink":"http://coderdog.duapp.com/2017/08/08/MVVM的基础原理与实现/","excerpt":"","text":"什么是MVVMMVVM的核心思想是数据驱动，数据（Model）通过ViewModel与视图（View）绑定，此时对Model的操作将映射为DOM更新，可以看出数据驱动使开发者不用关心DOM操作，只专注对数据的操作。 MVVM功能完备的框架，Vue、React、Angular等 一码胜千言下面是作者实现的一个仅具备简单数据驱动的MVVM Demo ViewModelViewModel作为数据驱动的核心，主要功能就是数据变化时维护DOM，那么一般如何检测数据变化呢？一种是通过显示调用设置方法，另一种就是基于 ES5 Object.defineProperty。 Object.defineProperty可以设置对象某个属性的set方法，在对这个对象某个属性赋值时，就可以编写符合自己需求的设置方法或执行一些逻辑处理。 上面Demo的实现思路是，递归遍历某个指定element下的childNodes，对nodeType为1并且包含指定属性的元素进行数据绑定处理。此属性的值就是Model对象的属性，从而将DOM与Model建立了联系。在不考虑性能的前提下，只要set方法被调用就可以直接将新值应用在DOM上。 ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了 原理重要不？如果你觉得不重要，那么真的不重要。","categories":[],"tags":[]},{"title":"DOM备忘录","slug":"DOM备忘录","date":"2017-07-29T08:09:53.000Z","updated":"2017-07-30T15:46:50.000Z","comments":true,"path":"2017/07/29/DOM备忘录/","link":"","permalink":"http://coderdog.duapp.com/2017/07/29/DOM备忘录/","excerpt":"","text":"document.anchors获取当前页面所有锚 document.forms获取当前页面所有表单 document.getElementById返回第一个匹配的元素 document.images获取当前页面所有图片 event.keycode对应键盘的按键code event.button鼠标点击的哪个按键，0=&gt;左键，1=&gt;中键，2=&gt;右键 event.clientX | clientY事件发生的坐标 event.screenX | screenY相对屏幕的X或Y的值 event.shiftKey点击shift返回1，否则返回0 IE环境event.srcElement等于FireFox的event.targetnodeType1：元素；2：属性；3：文本；8：注释；9：文档 fromvar f = document.getElementById(‘x’) f.action // 获取action的值 f.action = ‘some action’ // 设置action的值 f.method // 获取请求方法 如果input元素拥有name值，那么使用f.name的具体值即可获取对应的input元素 f.elements // 获取此form对象下的所有input元素 f.onsubmit = function(){ return false | true} // 返回false此表单不会提交 button disable = true // 禁用 disable = false | null // 启用 checkbox checked = true // 选中 checked = false // 取消 选中文本内容var text = document.getElementById(‘x’)text.select() // 选中文本域内容 下拉列表var selectDom = document.getElementById(‘x’) selectDom.selectedIndex // 选中的索引 selectDom.options // 列出options selectDom.length // 有几个可选项 selectDom.size = 3 // 设置选择框可见选项的数量 selectDom.multiple = true // 用来设置是否可以多选 如果options没有设置value属性，那么文本就是value 通过selectDom.remove(index)，移除对应的option 选中options，设置属性selected=”selected” Tablevar t = document.getElementById(‘x’) cellpadding 单元边沿与其内容之间的空白 cellspacing 规定单元格之间的空白 frame 规定外边框哪部分可见（void，above，below，hsides，lhs，rhs，vsides，box，border） t.rows()获取所有行 获取tr元素的rowIndex属性，使用deleteRow(rowIndex)来删除一行 insertRow(index)返回的row对象再执行，insertCell(index)返回cell对象 td标签使用colspan用来指定单元格横向跨越的列数，rowspan用来指定单元格纵向跨越的行数 AccessKey元素快捷访问 windows 12alt + keyFireFox shift + alt + key mac 1control + option + key frameset、frame、iframe frameset设置rows=”30%，30%，30%”，每一行占屏幕百分比高度 frameset设置cols=”30%，30%，30%”，每一行占屏幕百分比宽度 frame不能脱离frameset使用，但是iframe可以脱离文档使用 frame的frameset使用时不能有body标签 iframe的frameset使用时必须在body标签里 iframe单独使用时有无body标签都可以 通过src属性来设置框架源 window window.top 顶层窗口，可使用window.top != window.self来判断当前窗口是否是顶层窗口 window.open(URL,name,specs,replace) 打开窗口，name可填写target值 window.screen.availWidth | availHeight 屏幕可用宽度或高度 navigator appCodeName 浏览器的代码名 appName 浏览器的名称 appVersion 浏览器的平台和版本信息 cookieEnabled 指明浏览器中是否启用 cookie 的布尔值 platform 运行浏览器的操作系统平台 userAgent 由客户机发送服务器的user-agent 头部的值 location hash URL的锚部分 host URL的主机名和端口 hostname URL的主机名 href 完整的URL pathname URL路径名 port 服务器使用的端口号 protocol 协议(http、https) search queryString（如：?a=1&amp;b=2） location.reload() 重新加载页面 location.replace(url) 替换当前页面，浏览器不产生后退","categories":[],"tags":[]},{"title":"Jenkins使用及部署","slug":"Jenkins使用及部署","date":"2017-07-23T03:48:43.000Z","updated":"2017-07-23T06:41:08.000Z","comments":true,"path":"2017/07/23/Jenkins使用及部署/","link":"","permalink":"http://coderdog.duapp.com/2017/07/23/Jenkins使用及部署/","excerpt":"","text":"Build great things at any scaleJenkins是用来持续集成的利器，它可以帮我们打包（build）、跑测试（test）、部署到测试或者生产环境（deploy） 安装首先确保您的电脑安装了Docker，推荐国内docker镜像仓库网易蜂巢 12docker pull hub.c.163.com/library/jenkins:latestdocker run -p 8080:8080 -p 50000:50000 -v /your/home:/var/jenkins_home hub.c.163.com/library/jenkins:latest 命令介绍 docker pull image_path // 下载一个镜像 docker run // 启动容器 -p 将本地的8080映射到容器的8080 -v 将本地的路径挂载到容器的/var/jenkins_home路径 最后一个参数是镜像名称 还可加入-d命令，使容器可以运行在后台 使用docker run 命令执行后在浏览器打开 http://localhost:8080 按照下图步骤初始化jenkins 安装jenkins插件点击 系统管理 &gt; 管理插件 &gt; 可选插件 &gt; nodeJs Plugin 安装成功后 点击 系统管理 &gt; Global Tool Configuration，参考下图配置 配置SSH配置git访问权限，参考下图 第一步 第二步 我们配置SSH的方式访问代码仓库，把ssh的 私钥 复制到此处 创建Job 使用Git获取源代码 配置构建环境和脚本 控制台点击立即构建，待构建完成W显示的是个太阳说明构建成功。 总结本项目展示的是一个Web前端项目的构建过程，Jenkins还可以构建Android Apk，Java War包等更多构建需求。 构建执行完毕，可以执行各种bash命令以及SSH远程命令，完成最终的发布过程。","categories":[],"tags":[]},{"title":"Hexo部署总结","slug":"Hexo部署总结","date":"2017-07-02T15:44:03.000Z","updated":"2017-07-23T06:56:13.000Z","comments":true,"path":"2017/07/02/Hexo部署总结/","link":"","permalink":"http://coderdog.duapp.com/2017/07/02/Hexo部署总结/","excerpt":"","text":"写程序有一段时间了，最近特别想写点什么，把自己的一些想法与经验分享给热爱写码子的你。 HexoHexo是基于Node的一个博客框架，采用Markdown语法书写内容，框架本身拥有较多的第三方插件和主题包。结合Github的Pages服务，部署一个自己的博客真的是很方便。 环境准备既然Hexo是基于Node的，那么Node肯定就少不了，其次需要使用到Git Node 安装 下载Node 既然说到了Node，那么必须说一下Node的包管理工具NPM，通过npm命令可以很方便的安装和使用第三方库，并且具有很好的依赖管理。 NPM有个弱点，国人访问有点慢，此时推荐使用淘宝的NPM源taonpm来加速。 Git 安装 下载Git Hexo 安装1npm i hexo -g 安装好以后，你就可以使用hexo命令来创建blog了。 Hexo 常用命令init 创建一个博客项目12cd project-pathhexo init new 新建一片文章1hexo new 我是Hello clean 清理已生成的博客123hexo clean简写hexo c generate 生成博客123hexo generate简写hexo g deploy 部署博客123hexo deploy简写hexo d Hexo 部署写好了文章肯定是要分享给朋友们看的，那么这时就需要一个http服务器来部署我们的博客。 推荐给大家一个常用的方法，Github Pages 它提供了一个Http服务，方便我们快速部署website。 那么想用这个功能，前提就得有个Github账号，然后创建一个项目（记得把SSH Key提前设置到Github）。 将新建的项目地址复制到博客项目根目录下的_config.yml里面 123deploy: type: git repo: git@github.com:llb421270473/MyBlog.git // 自己的项目地址 Hexo 百度BAE部署Github Pages服务的确方便而且免费，缺点是国内访问慢，绑定的域名需要备案，否则各大手机软件会弹警告。 百度BAE的好处是速度快、稳定，最低0.1元/天，提供duapp的二级域名，从而免备案。 登录百度云，购买一个lighttpd-static的执行单元，代码版本工具选择git，内存大小根据需求自己选，几毛钱的差价而已。 _config.yml 配置如下123deploy: type: git repo: // BAE自己的项目地址 在.deploy_git/.git/config文件中追加如下内容，从而避免git上传报出文件内容过大的错误12[http] postBuffer = 524288000 配置域名现在注册域名就像淘宝购物这么简单，如果想给自己的博客分配个域名，那么这时Github Pages服务依旧可以帮助你。 首先将自己的域名使用CNAME的形式解析到 自己的账号.github.io 其次在项目根目录的source文件夹下创建一个名称为CNAME的文件 在CNAME文件里写好你的域名（下面是我的博客域名）1blog.coderdog.club source文件夹可以用来存储每次生成博客时需要拷贝的文件 一键部署package.json的scripts可以存储一个命令执行过程，那么使用这个特性我们写个超级简单的脚本 123\"scripts\": &#123; \"deploy\": \"hexo c &amp;&amp; hexo g &amp;&amp; hexo d\" &#125; 执行脚本就可以轻松部署了1npm run deploy","categories":[],"tags":[]}]}